// Generated by CoffeeScript 1.9.1
var fs, opts_factory, path, sources;

fs = require('fs');

path = require('path');

sources = {
  coffee: ['js'],
  css: ['min'],
  es6: ['js'],
  html: ['js', 'min'],
  jade: ['html', 'js'],
  js: ['min'],
  sass: ['css']
};

opts_factory = function(source, orig, cb) {
  var k, opts, ref, v;
  if (typeof orig === 'function' && (cb == null)) {
    ref = [orig], cb = ref[0], orig = ref[1];
  }
  if (typeof cb !== 'function') {
    throw new Error('Argument `callback` is a required function');
  }
  if ((orig != null) && typeof orig !== 'object') {
    throw new Error('Argument `options` must be object type');
  }
  opts = {};
  if (orig) {
    for (k in orig) {
      v = orig[k];
      opts[k] = v;
    }
  }
  if (opts.source == null) {
    opts.source = source;
  }
  if (opts.res == null) {
    opts.res = {
      errors: [],
      includes: [],
      warnings: []
    };
  }
  return [opts, cb];
};

module.exports = function(src, options) {
  var err_arg0, err_arg1, errors, fn, i, iface, k, len, opts, process, ref, res, source, target, targets, v;
  if (typeof src !== 'string') {
    err_arg0 = new Error('Argument #1 `source` must be string type');
  }
  if ((options != null) && typeof options !== 'object') {
    err_arg1 = new Error('Argument #2 `options` must be object type');
    options = {};
  }
  opts = {};
  ref = options || {};
  for (k in ref) {
    v = ref[k];
    opts[k] = v;
  }
  res = opts.res != null ? opts.res : opts.res = {
    errors: errors = [],
    includes: [],
    warnings: []
  };
  if (err_arg0) {
    errors.push(err_arg0);
  }
  if (err_arg1) {
    errors.push(err_arg1);
  }
  process = function(code, compiled, minified, cb) {
    var source, target;
    if (typeof cb !== 'function') {
      throw new Error('Argument #1 (only argument) must be a callback function');
    }
    if (errors.length) {
      return cb(errors[0], res);
    }
    if (code === null) {
      opts.file = path.resolve(src);
      return fs.readFile(opts.file, {
        encoding: 'utf8'
      }, function(err, code) {
        if (err) {
          errors.push(err);
        } else {
          res.source = code;
        }
        return process(code, compiled, minified, cb);
      });
    }
    if (compiled && typeof compiled === 'object') {
      source = compiled.source, target = compiled.target;
      if (opts.source == null) {
        opts.source = code;
      }
      return require('./compiler/' + source + '-' + target)(opts, function() {
        if (typeof res.compiled !== 'string') {
          res.compiled = '';
        }
        return process(code, (compiled = res.compiled), minified, cb);
      });
    }
    if (minified && typeof minified === 'object') {
      source = minified.source;
      if (res.compiled) {
        opts.source = res.compiled;
      }
      if (opts.source == null) {
        opts.source = code;
      }
      return require('./minifier/' + source)(opts, function() {
        if (typeof res.minified !== 'string') {
          res.minified = '';
        }
        return process(code, compiled, (minified = res.minified), cb);
      });
    }
    return cb(null, res);
  };
  iface = {
    file: {}
  };
  for (source in sources) {
    targets = sources[source];
    fn = function(source, target) {
      var base, ffn, sfn;
      sfn = (iface[source] != null ? iface[source] : iface[source] = {})[target] = function(cb) {
        if (target === 'min') {
          return process(src, false, {
            source: source
          }, cb);
        }
        return process(src, {
          source: source,
          target: target
        }, false, cb);
      };
      if (target !== 'min') {
        sfn.min = function(cb) {
          return process(src, {
            source: source,
            target: target
          }, {
            source: target
          }, cb);
        };
      }
      ffn = ((base = iface.file)[source] != null ? base[source] : base[source] = {})[target] = function(cb) {
        if (target === 'min') {
          return process(null, false, {
            source: source
          }, cb);
        }
        return process(null, {
          source: source,
          target: target
        }, false, cb);
      };
      if (target !== 'min') {
        return ffn.min = function(cb) {
          return process(null, {
            source: source,
            target: target
          }, {
            source: target
          }, cb);
        };
      }
    };
    for (i = 0, len = targets.length; i < len; i++) {
      target = targets[i];
      fn(source, target);
    }
  }
  return iface;
};
