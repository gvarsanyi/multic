// Generated by CoffeeScript 1.9.1
var fs, linters, opts_factory, path, sources,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

sources = {
  coffee: ['js'],
  css: ['min'],
  es6: ['js'],
  html: ['js', 'min'],
  jade: ['html', 'js'],
  js: ['min'],
  sass: ['css']
};

linters = ['coffee', 'es6', 'html', 'jade', 'js'];

opts_factory = function(source, orig, cb) {
  var k, opts, ref, v;
  if (typeof orig === 'function' && (cb == null)) {
    ref = [orig], cb = ref[0], orig = ref[1];
  }
  if (typeof cb !== 'function') {
    throw new Error('Argument `callback` is a required function');
  }
  if ((orig != null) && typeof orig !== 'object') {
    throw new Error('Argument `options` must be object type');
  }
  opts = {};
  if (orig) {
    for (k in orig) {
      v = orig[k];
      opts[k] = v;
    }
  }
  if (opts.source == null) {
    opts.source = source;
  }
  if (opts.res == null) {
    opts.res = {
      errors: [],
      includes: [],
      warnings: []
    };
  }
  return [opts, cb];
};

module.exports = function(src, options) {
  var err_arg0, err_arg1, errors, fn, i, iface, k, len, opts, process, ref, res, source, target, targets, v;
  if (typeof src !== 'string') {
    err_arg0 = new Error('Argument #1 `source` must be string type');
  }
  if ((options != null) && typeof options !== 'object') {
    err_arg1 = new Error('Argument #2 `options` must be object type');
    options = {};
  }
  opts = {};
  ref = options || {};
  for (k in ref) {
    v = ref[k];
    opts[k] = v;
  }
  res = opts.res != null ? opts.res : opts.res = {
    errors: errors = [],
    includes: [],
    warnings: []
  };
  if (err_arg0) {
    errors.push(err_arg0);
  }
  if (err_arg1) {
    errors.push(err_arg1);
  }
  process = function(lint_inf, compile_inf, minify_inf, cb) {
    var source, target;
    if (typeof cb !== 'function') {
      throw new Error('Argument #1 (only argument) must be a callback function');
    }
    if (errors.length) {
      return cb(errors[0], res);
    }
    if (opts.source == null) {
      opts.file = path.resolve(src);
      return fs.readFile(opts.file, {
        encoding: 'utf8'
      }, function(err, code) {
        if (err) {
          errors.push(err);
        } else {
          opts.source = res.source = code;
        }
        return process(lint_inf, compile_inf, minify_inf, cb);
      });
    }
    if (lint_inf && indexOf.call(linters, lint_inf) >= 0 && (opts.lint || (opts.lint == null))) {
      opts.lint = false;
      return require('./linter/' + lint_inf)(opts, function() {
        return process(lint_inf, compile_inf, minify_inf, cb);
      });
    }
    if (compile_inf && (res.compiled == null)) {
      source = compile_inf.source, target = compile_inf.target;
      return require('./compiler/' + source + '-' + target)(opts, function() {
        if (typeof res.compiled !== 'string') {
          res.compiled = '';
        }
        return process(lint_inf, compile_inf, minify_inf, cb);
      });
    }
    if (minify_inf && (res.minified == null)) {
      if (res.compiled) {
        opts.source = res.compiled;
      }
      return require('./minifier/' + minify_inf)(opts, function() {
        if (typeof res.minified !== 'string') {
          res.minified = '';
        }
        return process(lint_inf, compile_inf, minify_inf, cb);
      });
    }
    return cb(null, res);
  };
  iface = {
    file: {}
  };
  for (source in sources) {
    targets = sources[source];
    fn = function(source, target) {
      var base, base1, ffn, sfn;
      if (indexOf.call(linters, source) >= 0) {
        if (iface[source] == null) {
          iface[source] = function(cb) {
            opts.source = src;
            return process(source, false, false, cb);
          };
        }
        if ((base = iface.file)[source] == null) {
          base[source] = function(cb) {
            return process(source, false, false, cb);
          };
        }
      }
      sfn = (iface[source] != null ? iface[source] : iface[source] = {})[target] = function(cb) {
        opts.source = src;
        if (target === 'min') {
          return process(source, false, source, cb);
        }
        return process(source, {
          source: source,
          target: target
        }, false, cb);
      };
      if (target !== 'min') {
        sfn.min = function(cb) {
          opts.source = src;
          return process(source, {
            source: source,
            target: target
          }, target, cb);
        };
      }
      ffn = ((base1 = iface.file)[source] != null ? base1[source] : base1[source] = {})[target] = function(cb) {
        if (target === 'min') {
          return process(source, false, source, cb);
        }
        return process(source, {
          source: source,
          target: target
        }, false, cb);
      };
      if (target !== 'min') {
        return ffn.min = function(cb) {
          return process(source, {
            source: source,
            target: target
          }, target, cb);
        };
      }
    };
    for (i = 0, len = targets.length; i < len; i++) {
      target = targets[i];
      fn(source, target);
    }
  }
  return iface;
};
