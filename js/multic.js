// Generated by CoffeeScript 1.9.1
var fn, source, sources, targets;

sources = {
  coffee: ['js'],
  css: ['min'],
  es6: ['js'],
  html: ['js', 'min'],
  jade: ['html', 'js'],
  js: ['min'],
  sass: ['css']
};

fn = function(source, targets) {
  return module.exports[source] = function(compilable) {
    var fn1, i, len, res, target;
    if (typeof compilable !== 'string') {
      compilable = '';
    }
    res = {};
    fn1 = function(target) {
      var compile;
      compile = function(opts, cb) {
        var ref;
        if (typeof opts === 'function' && (cb == null)) {
          ref = [opts, {}], cb = ref[0], opts = ref[1];
        }
        if (!(opts && typeof opts === 'object')) {
          throw new Error('Argument `options` must be object type');
        }
        if (typeof cb !== 'function') {
          throw new Error('Argument `callback` is a required function');
        }
        opts.source = compilable;
        if (target === 'min') {
          return require('./minifier/' + target)(opts, cb);
        } else {
          return require('./compiler/' + source + '-' + target)(opts, cb);
        }
      };
      if (target !== 'min') {
        compile.min = function(opts, cb) {
          var ref;
          if (typeof opts === 'function' && (cb == null)) {
            ref = [opts, {}], cb = ref[0], opts = ref[1];
          }
          if (typeof cb !== 'function') {
            throw new Error('Argument `callback` is a required function');
          }
          return compile(opts, function(err, compiled, includes, warnings1) {
            var minifier;
            if (err) {
              return cb(err);
            }
            opts.source = compiled;
            minifier = require('./minifier/' + target);
            return minifier(opts, function(err, minified, warnings2) {
              var warnings;
              if (err) {
                return cb(err);
              }
              if ((warnings1 != null ? warnings1.length : void 0) || (warnings2 != null ? warnings2.length : void 0)) {
                warnings = (warnings1 || []).concat(warnings2 || []);
              }
              return cb(null, compiled, minified, includes, warnings);
            });
          });
        };
      }
      return res[target] = compile;
    };
    for (i = 0, len = targets.length; i < len; i++) {
      target = targets[i];
      fn1(target);
    }
    return res;
  };
};
for (source in sources) {
  targets = sources[source];
  fn(source, targets);
}

return;
