// Generated by CoffeeScript 1.9.1
var CompilationError, CompilationWarning, Jade, util,
  slice = [].slice;

CompilationError = require('../error/compilation-error');

CompilationWarning = require('../warning/compilation-warning');

Jade = require('jade');

util = require('util');

require('../patch/jade-patch');

console.log('Jade.Parser::parseInclude', Jade.Parser.prototype.parseInclude);

module.exports = function(inf, cb) {
  var cfg, desc, err, err_line, i, includes, len, line, orig_warn, pos, ref, ref1;
  if (inf.compiledJade != null) {
    inf.res.compiled = inf.compiledJade;
    return cb();
  }
  try {
    orig_warn = console.warn;
    console.warn = function() {
      var desc, file, fpos, i, item, len, line, mock, msg, msgs, pos, spos;
      msgs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      msg = [];
      for (i = 0, len = msgs.length; i < len; i++) {
        item = msgs[i];
        msg.push(typeof item === 'string' ? item : util.inspect(item));
      }
      msg = msg.join();
      if (msg.substr(0, 9) === 'Warning: ' && ((spos = msg.indexOf(' for line ')) > -1 || (spos = msg.indexOf(' on line ')) > -1)) {
        desc = msg.substr(9, spos);
        if (-1 < (fpos = msg.lastIndexOf(' file "'))) {
          file = msg.substr(fpos + 7);
          file = file.substr(0, file.length - 1);
        }
        line = msg.substr(spos + 1).split(' ')[2];
        pos = CompilationWarning.parsePos(line, null, -1);
        mock = {
          file: file,
          message: msg
        };
        return inf.res.warnings.push(new CompilationWarning(inf, mock, pos, desc));
      } else {
        return inf.res.warnings.push(new CompilationWarning(inf, msg));
      }
    };
    cfg = {
      compileDebug: false,
      pretty: true,
      includes: (includes = [])
    };
    if (inf.options.file) {
      cfg.filename = inf.options.file;
    }
    if (Array.isArray(inf.jadeNodes)) {
      cfg.nodes = inf.jadeNodes;
    }
    inf.res.compiled = Jade.render(inf.source, cfg);
    console.warn = orig_warn;
    if (Array.isArray(includes)) {
      (ref = inf.res.includes).push.apply(ref, includes);
    }
  } catch (_error) {
    err = _error;
    console.warn = orig_warn;
    desc = String(err).split('\n\n').slice(1).join('\n\n');
    ref1 = String(err).split('\n');
    for (i = 0, len = ref1.length; i < len; i++) {
      err_line = ref1[i];
      if (!(err_line.substr(0, 4) === '  > ')) {
        continue;
      }
      line = String(err_line.substr(4).split('|')[0]).trim();
      break;
    }
    pos = CompilationError.parsePos(line, null, -1);
    inf.res.errors.push(new CompilationError(inf, err, pos, desc));
  }
  return cb();
};
