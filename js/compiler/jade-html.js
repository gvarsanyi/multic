// Generated by CoffeeScript 1.9.1
var CompilationError, CompilationWarning, compiler, util,
  slice = [].slice;

CompilationError = require('../error/compilation-error');

CompilationWarning = require('../warning/compilation-warning');

compiler = require('jade');

util = require('util');

compiler.Parser.prototype._parseInclude = compiler.Parser.prototype.parseInclude;

compiler.Parser.prototype.parseInclude = function() {
  var base, file, i, item, len, list, p, path, ref, tok;
  if ((list = (ref = this.options) != null ? ref.includes : void 0) && typeof list === 'object') {
    tok = this.peek();
    path = this.resolvePath(tok.val.trim(), 'include');
    p = require('path');
    file = p.resolve(this.filename);
    path = p.resolve(path);
    if (list instanceof Array) {
      for (i = 0, len = list.length; i < len; i++) {
        item = list[i];
        if (item === path) {
          return this._parseInclude();
        }
      }
      list.push(path);
    } else {
      if (list[file] == null) {
        list[file] = {};
      }
      if ((base = list[file])[path] == null) {
        base[path] = [];
      }
      list[file][path].push(tok.line);
    }
  }
  return this._parseInclude();
};

module.exports = function(inf, cb) {
  var desc, err, err_line, i, includes, len, line, line_n, orig_warn, ref, ref1;
  try {
    orig_warn = console.warn;
    console.warn = function() {
      var desc, i, item, len, line, msg, msgs, pos;
      msgs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      msg = [];
      for (i = 0, len = msgs.length; i < len; i++) {
        item = msgs[i];
        msg.push(typeof item === 'string' ? item : util.inspect(item));
      }
      msg = msg.join();
      if (msg.substr(0, 9) === 'Warning: ' && ((pos = msg.indexOf(' for line ')) > -1 || (pos = msg.indexOf(' on line ')) > -1)) {
        desc = msg.substr(9, pos);
        if (isNaN(line = Number(msg.substr(pos + 1).split(' ')[2]))) {
          line = null;
        } else {
          line -= 1;
        }
        return inf.res.warnings.push(new CompilationWarning(inf, msg, line, desc));
      } else {
        return inf.res.warnings.push(new CompilationWarning(inf, msg));
      }
    };
    inf.res.compiled = compiler.render(inf.source, {
      filename: inf.file,
      compileDebug: false,
      pretty: true,
      includes: (includes = [])
    });
    console.warn = orig_warn;
    if (Array.isArray(includes)) {
      (ref = inf.res.includes).push.apply(ref, includes);
    }
  } catch (_error) {
    err = _error;
    console.warn = orig_warn;
    desc = String(err).split('\n\n').slice(1).join('\n\n');
    ref1 = String(err).split('\n');
    for (i = 0, len = ref1.length; i < len; i++) {
      err_line = ref1[i];
      if (err_line.substr(0, 4) === '  > ' && (line_n = String(err_line.substr(4).split('|')[0]).trim()) && !isNaN(line_n = Number(line_n))) {
        line = line_n - 1;
        break;
      }
    }
    inf.res.errors.push(new CompilationError(inf, err, line, desc));
  }
  return cb();
};
