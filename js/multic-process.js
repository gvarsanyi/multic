// Generated by CoffeeScript 1.9.1
var COMPILE, FINISHED, MINIFY, MulticProcess, PROCESSING, Promise, READ, REQUESTED, fs, path,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Promise = null;

fs = require('fs');

path = require('path');

REQUESTED = 1;

PROCESSING = 2;

FINISHED = 3;

READ = 1;

COMPILE = 2;

MINIFY = 4;

MulticProcess = (function() {
  MulticProcess.prototype.callback = null;

  MulticProcess.prototype.options = null;

  MulticProcess.prototype.promiseReject = null;

  MulticProcess.prototype.promiseResolve = null;

  MulticProcess.prototype.res = null;

  MulticProcess.prototype.req = null;

  MulticProcess.prototype.source = null;

  function MulticProcess(source, options) {
    this.source = source;
    this.options = options != null ? options : {};
    this.process = bind(this.process, this);
    this.start = bind(this.start, this);
    if (!(typeof this.source === 'string' && this.source)) {
      throw new Error('Argument #1 `source` must be string type: source or ' + 'source file path');
    }
    if (typeof this.options !== 'object') {
      throw new Error('Argument #2 `options` must be object type');
    }
    if (this.options.file != null) {
      if (!(typeof this.options.file === 'string' && (this.options.file = path.resolve(this.options.file)))) {
        throw new Error('options.file must be a valid URL string');
      }
    }
    this.cue = [];
    this.res = {
      errors: [],
      includes: [],
      warnings: []
    };
    this.req = {
      lint: REQUESTED
    };
  }

  MulticProcess.prototype.start = function(todo, source_type, target_type, callback) {
    if (this.promiseResolve || this.callback) {
      throw new Error('Duplicate processing is forbidden');
    }
    if ((callback != null) && typeof callback !== 'function') {
      throw new Error('Argument #1 (only argument) must be a callback function');
    }
    this.callback = callback;
    this.sourceType = source_type;
    this.targetType = target_type;
    if (todo & READ) {
      this.req.read = REQUESTED;
    }
    if (todo & COMPILE) {
      this.req.compile = REQUESTED;
    }
    if (todo & MINIFY) {
      this.req.minify = REQUESTED;
    }
    if (this.callback) {
      this.process();
      return;
    }
    if (Promise == null) {
      Promise = require('promise');
    }
    return new Promise((function(_this) {
      return function(promiseResolve, promiseReject) {
        _this.promiseResolve = promiseResolve;
        _this.promiseReject = promiseReject;
        return _this.process();
      };
    })(this));
  };

  MulticProcess.prototype.process = function() {
    var finish;
    finish = (function(_this) {
      return function() {
        var err;
        err = _this.res.errors[0] || null;
        if (_this.callback) {
          _this.callback(err, _this.res);
        } else if (err) {
          err.res = _this.res;
          _this.promiseReject(err);
        } else {
          _this.promiseResolve(_this.res);
        }
      };
    })(this);
    if (this.res.errors.length) {
      return finish();
    }
    if (this.req.read === REQUESTED) {
      this.req.read = PROCESSING;
      this.options.file = path.resolve(this.source);
      return fs.readFile(this.options.file, {
        encoding: 'utf8'
      }, (function(_this) {
        return function(err, code) {
          if (err) {
            _this.res.errors.push(err);
          }
          _this.source = _this.res.source = code || '';
          _this.req.read = FINISHED;
          return _this.process();
        };
      })(this));
    }
    if (this.req.lint === REQUESTED) {
      this.req.lint = PROCESSING;
      return require('./linter/' + this.sourceType)(this, (function(_this) {
        return function() {
          _this.req.lint = FINISHED;
          return _this.process();
        };
      })(this));
    }
    if (this.req.compile === REQUESTED) {
      this.req.compile = PROCESSING;
      return require('./compiler/' + this.sourceType + '-' + this.targetType)(this, (function(_this) {
        return function() {
          _this.req.compile = FINISHED;
          if (typeof _this.res.compiled !== 'string') {
            _this.res.compiled = '';
          }
          return _this.process();
        };
      })(this));
    }
    if (this.req.minify === REQUESTED) {
      this.req.minify = PROCESSING;
      if (this.res.compiled != null) {
        this.source = this.res.compiled;
      }
      return require('./minifier/' + this.targetType)(this, (function(_this) {
        return function() {
          _this.req.minify = FINISHED;
          if (typeof _this.res.minified !== 'string') {
            _this.res.minified = '';
          }
          return _this.process();
        };
      })(this));
    }
    return finish();
  };

  return MulticProcess;

})();

module.exports = MulticProcess;
