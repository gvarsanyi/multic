// Generated by CoffeeScript 1.9.1
var COMPILE, FINISHED, MINIFY, MulticProcess, PROCESSING, READ, REQUESTED, fs, path,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

fs = require('fs');

path = require('path');

REQUESTED = 1;

PROCESSING = 2;

FINISHED = 3;

READ = 1;

COMPILE = 2;

MINIFY = 4;

MulticProcess = (function() {
  MulticProcess.prototype.flushed = false;

  MulticProcess.prototype.options = null;

  MulticProcess.prototype.res = null;

  MulticProcess.prototype.req = null;

  MulticProcess.prototype.source = null;

  function MulticProcess(source, options) {
    this.source = source;
    this.options = options != null ? options : {};
    this.process = bind(this.process, this);
    if (!(typeof this.source === 'string' && this.source)) {
      throw new Error('Argument #1 `source` must be string type: source or ' + 'source file path');
    }
    if (typeof this.options !== 'object') {
      throw new Error('Argument #2 `options` must be object type');
    }
    if (this.options.file != null) {
      if (!(typeof this.options.file === 'string' && (this.options.file = path.resolve(this.options.file)))) {
        throw new Error('options.file must be a valid URL string');
      }
    }
    this.cue = [];
    this.res = {
      errors: [],
      includes: [],
      warnings: []
    };
    this.req = {
      lint: REQUESTED
    };
  }

  MulticProcess.prototype.process = function(todo, source_type, target_type, cb, iter) {
    if (typeof cb !== 'function') {
      throw new Error('Argument #1 (only argument) must be a callback function');
    }
    if (!iter) {
      if (this.flushed) {
        throw new Error('Duplicate processing is forbidden');
      } else {
        if (todo & READ) {
          this.req.read = REQUESTED;
        }
        if (todo & COMPILE) {
          this.req.compile = REQUESTED;
        }
        if (todo & MINIFY) {
          this.req.minify = REQUESTED;
        }
      }
      this.flushed = true;
    }
    if (this.res.errors.length) {
      cb(this.res.errors[0], this.res);
      return;
    }
    if (this.req.read === REQUESTED) {
      this.req.read = PROCESSING;
      this.options.file = path.resolve(this.source);
      fs.readFile(this.options.file, {
        encoding: 'utf8'
      }, (function(_this) {
        return function(err, code) {
          if (err) {
            _this.res.errors.push(err);
          }
          _this.source = _this.res.source = code || '';
          _this.req.read = FINISHED;
          return _this.process(todo, source_type, target_type, cb, true);
        };
      })(this));
      return;
    }
    if (this.req.lint === REQUESTED) {
      this.req.lint = PROCESSING;
      require('./linter/' + source_type)(this, (function(_this) {
        return function() {
          _this.req.lint = FINISHED;
          return _this.process(todo, source_type, target_type, cb, true);
        };
      })(this));
      return;
    }
    if (this.req.compile === REQUESTED) {
      this.req.compile = PROCESSING;
      require('./compiler/' + source_type + '-' + target_type)(this, (function(_this) {
        return function() {
          _this.req.compile = FINISHED;
          if (typeof _this.res.compiled !== 'string') {
            _this.res.compiled = '';
          }
          return _this.process(todo, source_type, target_type, cb, true);
        };
      })(this));
      return;
    }
    if (this.req.minify === REQUESTED) {
      this.req.minify = PROCESSING;
      if (this.res.compiled != null) {
        this.source = this.res.compiled;
      }
      require('./minifier/' + target_type)(this, (function(_this) {
        return function() {
          _this.req.minify = FINISHED;
          if (typeof _this.res.minified !== 'string') {
            _this.res.minified = '';
          }
          return _this.process(todo, source_type, target_type, cb, true);
        };
      })(this));
      return;
    }
    cb(null, this.res);
  };

  return MulticProcess;

})();

module.exports = MulticProcess;
