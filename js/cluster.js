// Generated by CoffeeScript 1.9.2
var MulticProcess, callbacks, cluster, create_worker, i, j, k, os, ref, req_id, stopped, worker_list, worker_message, workers;

cluster = require('cluster');

os = require('os');

MulticProcess = require('./multic-process');

stopped = null;

workers = {};

worker_list = [];

module.exports.stop = function(cb) {
  var id, node;
  if (stopped === true) {
    return typeof cb === "function" ? cb() : void 0;
  }
  if (cb) {
    cluster.disconnect(cb);
  }
  stopped = true;
  delete MulticProcess.clusterProxy;
  for (id in workers) {
    node = workers[id];
    try {
      if (!node.worker.suicide) {
        node.worker.disconnect();
      }
    } catch (_error) {}
  }
};

for (k in cluster.settings) {
  return;
}

cluster.setupMaster({
  exec: __dirname + '/worker.js'
});

worker_message = function(worker, msg) {
  var cb;
  switch (msg != null ? msg.req : void 0) {
    case 'processed':
      if (cb = callbacks[msg.reqId]) {
        delete callbacks[msg.reqId];
        return cb(msg.err, msg.res);
      }
      break;
    case 'ready':
      workers[worker.id].ready = true;
      return worker_list.push(worker);
  }
};

create_worker = function() {
  var worker, worker_id;
  worker = cluster.fork();
  worker_id = worker.id;
  workers[worker_id] = {
    worker: worker
  };
  return (function(worker, worker_id) {
    worker.on('message', function(msg) {
      return worker_message(worker, msg);
    });
    return worker.on('disconnect', function() {
      var node;
      worker_list = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = worker_list.length; j < len; j++) {
          node = worker_list[j];
          if (node.id !== worker_id) {
            results.push(node);
          }
        }
        return results;
      })();
      delete workers[worker_id];
      if (stopped !== true) {
        return create_worker();
      }
    });
  })(worker, worker_id);
};

for (i = j = 0, ref = Math.max(4, os.cpus().length); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
  create_worker();
}

req_id = 0;

callbacks = {};

MulticProcess.clusterProxy = function(inf) {
  var worker;
  if (!worker_list.length) {
    return false;
  }
  worker_list.push(worker = worker_list.shift());
  req_id += 1;
  callbacks[req_id] = (function(_this) {
    return function(err, res) {
      var key, l, len, len1, len2, m, n, node, node_key, ref1, ref2, ref3, ref4, value;
      ref1 = ['source', 'compiled', 'minified'];
      for (l = 0, len = ref1.length; l < len; l++) {
        key = ref1[l];
        if (res[key] != null) {
          inf.res[key] = res[key];
        }
      }
      if (Array.isArray(res.includes)) {
        (ref2 = inf.res.includes).push.apply(ref2, res.includes);
      }
      ref3 = ['errors', 'warnings'];
      for (m = 0, len1 = ref3.length; m < len1; m++) {
        key = ref3[m];
        if (Array.isArray(res[key])) {
          ref4 = res[key];
          for (n = 0, len2 = ref4.length; n < len2; n++) {
            node = ref4[n];
            err = new Error(node.message);
            for (node_key in node) {
              value = node[node_key];
              if (key !== 'message') {
                err[node_key] = value;
              }
            }
            inf.res[key].push(err);
          }
        }
      }
      return inf.finish();
    };
  })(this);
  worker.send({
    req: 'process',
    reqId: req_id,
    source: inf.source,
    options: inf.options,
    todo: inf.todo,
    sourceType: inf.sourceType,
    targetType: inf.targetType
  });
  return true;
};
