// Generated by CoffeeScript 1.9.2
var Jade, fs, orig_jade_render, path, util,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

Jade = require('jade');

fs = require('fs');

path = require('path');

util = require('util');

Jade.Parser.prototype._multicPatch_parseInclude = Jade.Parser.prototype.parseInclude;

Jade.Parser.prototype.parseInclude = function() {
  var include_path, include_sources, includes, read_file_sync, ref, ref1, res, token;
  if (Array.isArray(includes = (ref = this.options) != null ? ref._multic_includes : void 0)) {
    if (token = this.peek()) {
      include_path = this.resolvePath(token.val.trim(), 'include');
      if (indexOf.call(includes, include_path) < 0) {
        includes.push(include_path);
      }
    }
  }
  read_file_sync = fs.readFileSync;
  if ((include_sources = (ref1 = this.options) != null ? ref1._multic_includeSources : void 0) && typeof include_sources === 'object') {
    fs.readFileSync = function(file_path, opts) {
      var name;
      return include_sources[name = path.resolve(file_path)] != null ? include_sources[name] : include_sources[name] = read_file_sync(file_path, opts);
    };
  }
  try {
    res = this._multicPatch_parseInclude();
  } finally {
    fs.readFileSync = read_file_sync;
  }
  return res;
};

Jade.Parser.prototype._multicPatch_parseExpr = Jade.Parser.prototype.parseExpr;

Jade.Parser.prototype.parseExpr = function() {
  var expr, ref, ref1;
  expr = this._multicPatch_parseExpr();
  if (Array.isArray((ref = this.options) != null ? ref.nodes : void 0)) {
    if ((ref1 = this.options) != null) {
      ref1.nodes.push(expr);
    }
  }
  return expr;
};

orig_jade_render = Jade.render;

Jade.render = function(str, options, fn) {
  var orig_warn, res, warnings;
  orig_warn = console.warn;
  if (Array.isArray(warnings = options != null ? options._multic_warnings : void 0)) {
    console.warn = function() {
      var desc, err, file, fpos, i, item, len, line, mock, msg, msgs, spos, warning_line;
      msgs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      msg = [];
      for (i = 0, len = msgs.length; i < len; i++) {
        item = msgs[i];
        msg.push(typeof item === 'string' ? item : util.inspect(item));
      }
      msg = msg.join();
      if (msg.substr(0, 9) !== 'Warning: ') {
        return orig_warn.apply(null, msgs);
      }
      mock = {};
      if ((spos = msg.indexOf(' for line ')) > -1 || (spos = msg.indexOf(' on line ')) > -1) {
        desc = msg.substr(9, spos);
        if (((line = msg.substr(spos + 1).split(' ')[2]) != null) && line > 0 && parseInt(line, 10) === (line = Number(line))) {
          warning_line = line - 1;
        }
      }
      if (-1 < (fpos = msg.lastIndexOf(' file "'))) {
        file = msg.substr(fpos + 7);
        file = path.resolve(file.substr(0, file.length - 1));
      }
      warnings.push(err = new Error(desc));
      if (warning_line) {
        err.line = warning_line;
      }
      if (file) {
        err.file = file;
      }
    };
  }
  try {
    res = orig_jade_render(str, options, fn);
  } finally {
    console.warn = orig_warn;
  }
  return res;
};
