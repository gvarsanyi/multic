// Generated by CoffeeScript 1.9.1
var LintError, LintWarning, allowed_globals, eol_eof, lint_map, linter;

LintError = require('../error/lint-error');

LintWarning = require('../warning/lint-warning');

eol_eof = require('./common/eol-eof');

linter = require('coffeelint').lint;

lint_map = {
  errors: {
    duplicate_key: 'duplicate_key'
  },
  mandatory_warnings: {
    no_comparison_assignments: 0,
    no_debugger: 'no_debugger',
    no_deprecated_iterator: 0,
    no_deprecated_proto: 0,
    no_eval: 0,
    no_native_prototype_extension: 0,
    no_operator_parentheses: 0,
    no_undefined: 0,
    no_unused: 0,
    ensure_comprehensions: 'ensure_comprehensions'
  },
  enabled_warnings: {
    file_end_newline: true,
    indentation: {
      name: 'indentation',
      property: 'indentation',
      value: [false, 2, 4]
    },
    line_end: true,
    line_end_whitespace: true,
    no_tabs: 'no_tabs',
    braces_spacing: {
      name: 'braces_spacing',
      property: 'spacing',
      values: [false, 0, 1]
    },
    camel_case_classes: 'camel_case_classes',
    colon_assignment_spacing: {
      name: 'colon_assignment_spacing',
      property: ['spacing', 'left'],
      values: [false, 0]
    },
    no_arguments_caller_or_callee: 0,
    no_interpolation_in_single_quotes: 'no_interpolation_in_single_quotes',
    no_non_breaking_space: 0,
    no_throwing_strings: 'no_throwing_strings',
    no_unnecessary_brackets: 0,
    quote_consistency: 'prefer_single_quotes',
    space_operators: 'space_operators',
    spacing_after_comma: 'spacing_after_comma',
    typeof_value: 0,
    arrow_spacing: 'arrow_spacing',
    no_backticks: 'no_backticks',
    no_empty_param_list: 'no_empty_param_list',
    no_implicit_braces: 'no_implicit_braces',
    no_trailing_semicolons: 'no_trailing_semicolons',
    no_unnecessary_fat_arrows: 'no_unnecessary_fat_arrows',
    prefer_english_operators: 'prefer_english_operator'
  },
  disabled_warnings: {
    max_line_length: true,
    camel_case_variables: 0,
    constructor_parentheses_required: 'empty_constructor_needs_parens',
    no_comma_operator: 0,
    no_plusplus: true,
    no_implicit_parentheses: ['no_implicit_parentheses', 'non_empty_constructor_needs_parens']
  },
  disabled_rules: ['cyclomatic_complexity', 'line_endings', 'max_line_length', 'newlines_after_classes', 'no_empty_functions', 'no_stand_alone_at', 'no_trailing_whitespace', 'transform_messes_up_line_numbers']
};

allowed_globals = {};

module.exports = function(inf, cb) {
  var cfg, col, desc, err, i, len, line, msg, parts, pos, ref, ref1, rule, title, warn_level;
  try {
    warn_level = {
      level: 'warn'
    };
    cfg = {
      arrow_spacing: warn_level,
      braces_spacing: warn_level,
      duplicate_key: {
        level: 'error'
      },
      camel_case_classes: warn_level,
      colon_assignment_spacing: warn_level,
      no_backticks: warn_level,
      no_debugger: warn_level,
      no_empty_param_list: warn_level,
      no_implicit_braces: warn_level,
      no_interpolation_in_single_quotes: warn_level,
      no_plusplus: warn_level,
      no_tabs: warn_level,
      no_throwing_strings: warn_level,
      no_trailing_semicolons: warn_level,
      no_unnecessary_double_quotes: warn_level,
      no_unnecessary_fat_arrows: warn_level,
      prefer_english_operator: warn_level,
      prefer_single_quotes: warn_level,
      space_operators: warn_level,
      spacing_after_comma: warn_level,
      no_trailing_whitespace: {
        level: 'ignore'
      },
      max_line_length: {
        level: 'ignore'
      }
    };
    ref = linter(inf.source, cfg);
    for (i = 0, len = ref.length; i < len; i++) {
      msg = ref[i];
      rule = msg.rule ? '[' + msg.rule + '] ' : '';
      if (typeof msg.message === 'string') {
        if (msg.message.substr(0, 7) === '[stdin]') {
          parts = msg.message.split(' ');
          ref1 = parts[0].substr(8).split(':'), line = ref1[0], col = ref1[1];
          msg.message = parts.slice(1).join(' ');
        }
        msg.message = msg.message.split('\u001b')[0];
        if ((pos = msg.message.lastIndexOf('\n')) > -1) {
          msg.message = msg.message.substr(0, pos);
        }
        if (msg.description) {
          desc = rule + msg.description.split('\n<pre>')[0];
          title = msg.message;
        }
      }
      pos = LintError.parsePos(msg.lineNumber || line, col, -1, -1);
      if (msg.level === 'error') {
        if (title == null) {
          title = rule + 'Error';
        }
        inf.res.errors.push(new LintError(inf, msg, pos, desc, title));
      } else {
        if (title == null) {
          title = rule + 'Lint warning';
        }
        inf.res.warnings.push(new LintWarning(inf, msg, pos, desc, title));
      }
    }
    eol_eof(inf);
  } catch (_error) {
    err = _error;
    inf.res.errors.push(new LintError(inf, err));
  }
  return cb();
};
