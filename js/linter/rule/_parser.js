// Generated by CoffeeScript 1.9.2
var LintError, LintWarning, levels;

LintError = require('../../error/lint-error');

LintWarning = require('../../warning/lint-warning');

levels = {
  errors: 'error',
  mandatory_warnings: 'warn',
  enabled_warnings: 'warn',
  disabled_warnings: 'warn',
  disabled_rules: 'ignore'
};

module.exports = function(inf, source_type, cb, next) {
  var base, cfg, file, i, idea, item, j, keys, len, len1, level, map, multic_linter, name, name1, pos, prop_lint, property, ref, ref1, ref2, rule, rules, todo, v, value, values;
  map = require('../map/' + source_type);
  cfg = {};
  todo = [];
  prop_lint = function(rule_module, subtype, rule, level, file) {
    var msg_class, msg_factory, ref1, source, target, title;
    title = rule[0].toUpperCase() + rule.substr(1).split('_').join(' ');
    target = {
      error: 'errors',
      warn: 'warnings'
    }[level];
    msg_class = {
      error: LintError,
      warn: LintWarning
    }[level];
    msg_factory = function(desc, line, col, msg_file) {
      var mock;
      mock = {};
      if (msg_file != null ? msg_file : msg_file = file) {
        mock.file = msg_file;
      }
      return inf.res[target].push(new msg_class(inf, mock, [line, col], desc, title));
    };
    msg_factory["class"] = msg_class;
    if (subtype === 'map') {
      return multic_linter.map(msg_factory, inf.sourceMap, inf.options[rule]);
    } else if (file == null) {
      return multic_linter.source(msg_factory, inf.source, inf.options[rule]);
    } else if (source = (ref1 = inf.includeSources) != null ? ref1[file] : void 0) {
      return multic_linter.source(msg_factory, source, inf.options[rule]);
    }
  };
  for (idea in map) {
    rules = map[idea];
    for (rule in rules) {
      ref = rules[rule];
      if (!(ref !== 0)) {
        continue;
      }
      level = levels[idea];
      if (!((idea === 'errors' || idea === 'mandatory_warnings') || (idea === 'enabled_warnings' && ((v = inf.options[rule]) || (v == null))) || (idea === 'disabled_warnings' && inf.options[rule]))) {
        level = 'ignore';
      }
      if (ref === true) {
        if (level !== 'ignore') {
          multic_linter = require('./' + rule);
          if (multic_linter.map) {
            prop_lint(multic_linter, 'map', rule, level);
          }
          if (multic_linter.source) {
            prop_lint(multic_linter, 'source', rule, level);
            ref1 = inf.res.includes;
            for (i = 0, len = ref1.length; i < len; i++) {
              file = ref1[i];
              prop_lint(multic_linter, 'source', rule, level, file);
            }
          }
          if (inf.res.errors.length) {
            return cb(inf.res.errors[0]);
          }
        }
        continue;
      }
      ref2 = (Array.isArray(ref) ? ref : [ref]);
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        item = ref2[j];
        if (typeof item === 'string') {
          name = item;
          keys = null;
          values = [false, true];
        } else {
          name = item.name, property = item.property, values = item.values;
          keys = Array.isArray(property) ? property : [property];
        }
        if (name[0] === '!') {
          name = name.substr(1);
          if (level === 'ignore') {
            level = idea === 'errors' ? 'error' : 'warn';
          } else {
            level = 'ignore';
          }
        }
        if (level === 'ignore') {
          value = values[0];
        } else {
          value = values[1];
          if (-1 < (pos = values.indexOf(inf.options[rule]))) {
            value = values[pos];
          }
        }
        if (source_type === 'coffee') {
          cfg[name] = {
            level: level
          };
          if (keys && value !== true && value !== false) {
            if (keys.length === 2) {
              ((base = cfg[name])[name1 = keys[0]] != null ? base[name1] : base[name1] = {})[keys[1]] = value;
            } else {
              cfg[name][keys[0]] = value;
            }
          }
        } else {
          cfg[name] = value;
        }
      }
    }
  }
  return next(cfg);
};
